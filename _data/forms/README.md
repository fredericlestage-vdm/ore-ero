# Solution for auto-generating forms and their associated schema (English)

*English content Below | Le contenu en français viens après la section anglaise.*

Inspired from the core principles of [Netlify Cms](https://www.netlifycms.org/), this system was built and adapted to better fit this project specificity.

The following documentation will attempt to explain how forms and schema pages can be auto-generated by using a simple `.yml` file, in concordance with the form and schema layouts and the translation documents in the `_data/i18n/` folder. However, there are still some limits to the automation process up till now, and some javascript is still required for the forms to work properly.

This document describes how each solution element works. Instructions on how to use, update and create solution elements are also presented.

## Pages
Found under the `_pages/` folder, pages must follow the template below so that all the data that you will set up next be pulled.

**WARNING** When creating or updating pages, make sure that changes are applied to both languages! Find the corresponding pages in `_pages/en` and `_pages/fr`. Look for pages that have the same `ref` value in their header.

In general, pages have the header variables presented below. These header variables must be included in any form or schema page (an example is provided at the end of the list).
 - `layout`: defines which layout structure to follow. Its default value is "default". Layouts are defined in the `_layouts/` folder.
 -  `ref`: defines the page's ID, which is unique between different pages. However, a french page must have the same `ref` value as its corresponding english page and vice-versa, allowing the website to redirect to the proper page when switching between languages, as pages might not have the same name in both languages. For instance, an english index page and a french index page must both have the same `ref` variable value, and this value will be different for all other pages.

> How is `ref` used? When switching between languages, pages are generated using Jekyll/Liquid. It looks for all the pages that have the same `ref` value as the current page, but a different `lang` value, and adds their links to the language switcher navbar.

 -  `lang`: defines the associated language of the page. Used mostly as `[page.lang]` throughout the templates, it selects the correct value for a translation. The accepted values are either in `EN` or `FR` (case is important).
> Every translation follows this template:
> ```yaml
> example:
>    en: English value
>    fr: French value
>    ```
>    So to call the translation for the "example" keyword, we would use the following: ``{{ example[page.lang] }}``. Using ``[page.lang]`` simplifies content creation, as we don't have to worry about the current language for each individual page. Il also enables us to freely use includes without having to create a duplicate for each language, as page variables are applicable to all components included in said page.
 - `permalink`: The permalink for the page (at least the part that will be appended to the base URL of the website) overrides the file location in the folders when the website is compiled. Follow the convention `/[lang]/[page name].html`.

**Header example for a normal page**
```yaml
---
layout: default
ref: example
lang: en
permalink: /en/example.html
---
```

### Form page
Form pages require a few adjustments:
 - `layout`: form pages use "form" as their layout value instead of the default one.
 - `config`: refers to the name of the Yaml file in `_data/forms/` associated with the current form. That's how the relation is created between the current layout and the required data for the form.

**Header example for a form page**
```yaml
---
layout: form
ref: exampleForm
lang: en
permalink: /en/example-form.html
config: config-example  # Will fetch _data/forms/config-example.yml
---
```

### Schema page
Schema pages use the same parameters as form pages, but the `layout` variable must be set to "schema". In addition, the schema and form pages that are associated to one another must have the same `config` value. That way, both pages can pull from the same data.

**Header example for a schema page**
```yaml
---
layout: schema
ref: exampleSchema
lang: en
permalink: /en/example-schema.html
config: config-example
---
```

## Layouts
Forms and schema pages pull from the same two layouts that act as templates in which data (extracted from the config files) will be added.
### Form layout
Found under `_layouts/form.html`, it inherits from the default layout as to include the header, footer and other fixed components of the website.

#### How it works
First, using `{{ page.content }}`, the content defined in the page using this layout is added. The aim is to include all page-specific contents you wish to add.

Then comes the *form tag* which includes:

- the classes and IDs which are required for the form validation plugin (that comes with the [WET-BOEW](https://wet-boew.github.io/wet-boew/docs/ref/formvalid/formvalid-en.html) template)
- the `idPresets` definition. This variable refers to the first-level group "presets" in the translation file. It is declared only once to avoid duplication of definition
- an `include` call to the form loop (`loop.html`), allowing the template system to look for the values in the config file and to include the right elements to the form
- an `include` call to the submitter file. Contact information of the person submitting the form (name and email address) are required for the creation of the pull requests. Since we're currently using an anonymous bot to create all pull requests, the information requested allow to keep track of who submitted the changes.
- the submit and reset buttons. Note that the submit button has a unique id corresponding to `prbotSubmit{{ page.ref }}` where `{{ page.ref }}` refers to the value of `ref` in the page header. This will come up later in the JavaScript files, when binding the submit event to the button. It was added to better distinguish between the different submit function calls and to prevent errors. Various alerts are then added, improving the user experience.

All these elements are located in the layout instead of the page or config file since they should all appear in the form page, regardless which form the page is referring to.

### Schema layout
Found under `_layouts/schema.html`, it inherits from the default layout as to include the header, footer and other fixed components of the website.

#### How it works
First, using `{{ page.content }}`, the content defined in the page using this layout is added. The aim is to include all page-specific contents you wish to add. Finally, the loop is included to the schema page.

## Config files
The config files are the backbone of the solution. They specify each component that should be included in the form and schema, as well as its parameters.

**Here's an example file with default values:**

 - `~` represents an undefined default value
 - Every value is a string, unless specified otherwise using comments
	 - `# enum()` indicates that the field has specific values and that any other value will result in an error

Note that the list of available presets and widgets, as well as their parameters, are presented later on, in their corresponding sections.
```yaml
---

id: example

formGroups:
  - preset: ~  # enum()
  - widget: ~  # enum()
    title: ~
    type: text
    rule: ~  # enum()
    required: true  # bool

```

### Presets
Found under `_includes/[form/schema]/presets/`, presets are a set of (mostly) static sections that rarely take in parameters and should be used as is. Preset are created in one of the following situations:
-  when a section is called from two or more forms, as it made more sense to have it predefined instead of having to specify the same parameters of a widget twice
- when the section is too specific or doesn't fit in any of the widgets, either because it has some minor changes that would have been too specific to add as a parameter, or because the format is completely different from any widget

The following sections explain each of the available presets:
 - adminCode
 - contact
 - dates
 - description
 - empty
 - homepageURL
 - hr
 - languages
 - licence
 - newAdmin
 - orgLevel
 - provinceSelect
 - relatedCode
 - selectCode, selectOss, and selectStandard
 - status
 - submitter
 - tags

#### adminCode
The adminCode preset displays a `<select>` widget for administrations, which are separated into groups for each level of government (federal, provincial, municipal, aboriginal, etc.). You can check the list of administrations in `_data/administrations/[level of gov.].yml`.

The select widget is followed by a button, allowing the user to create a new administration in case his administration was not already in that list. The button opens a new section in the form, containing the required fields for the creation of a new administration. For more information on these fields, consult the **newAdmin** preset section.

When selecting the appropriate administration (depending on the type of the form), JavaScript should be added to auto-fill the administration section of the form. This follows the same logic as for the **selectCode**, **selectOss**, and **selectStandard** presets.

This preset takes no additional parameters.
```yaml
  - preset: adminCode
```

#### contact
The contact preset displays a group of fields (name and email address) of the person or organization to contact for general inquiries regarding the open source project.

This preset takes one *optional* parameter:
 - `phone`: specifies if the phone field should be added or not. Its default value is `true`.
```yaml
  - preset: contact
    phone: true  # bool
```

#### dates
The date preset displays a group of fields for the project specific dates; when the project was created, when it started, when it was last modified, and when its data on ore-ero were last updated.

This preset takes three **required** parameters:
 - `created`: specifies if the created date input should be added
 - `started`: specifies if the started date input should be added
 - `modified`: specifies if the last modified date input should be added
```yaml
  - preset: dates
    created: false  # bool
    started: false  # bool
    modified: false  # bool
```
Note that the date group will be left empty in case these parameters were not defined, except for the date when the metadata was last updated: this parameter is included by default and its value is locked to today's date.

To simplify the code, you can simply omit any value you wish to hide, and specify to true the values that you wish to display.
```yaml
  - preset: dates
    created: true
    modified: true
```

#### description
The description preset displays two fields, one for the english and the other for the french description of the current project. This preset was created since at least two of the forms made use of a description field.

This preset takes no additional parameters.
```yaml
  - preset: description
```

#### empty
The empty preset does not display anything in the form, but rather serves only as an [array] wrapper in the schema when there is a list of elements that are only updated as individual elements in the form. For instance, for the "release" array of the code schema (`_data/schemaCode.yaml`), it makes no sense to change the layout of the form to adapt to an array since only one release can be updated at a time. However, this should still be displayed as an array in the schema page.

This preset takes two **required** parameters:
 - `start` defines whether it is the start or the end of the array element in the schema (decides to add either the beginning or the ending html markup).
- `title` defines the name of the array element in the schema (also used for the translations, see the widget section for more information about title parameters)
```yaml
  - preset: empty
    start: false  # bool
    title: example
# Beginning a group / array
```
OR
```yaml
  - preset: empty
# Closing a group / array
```
The beginning and the ending markup are located under `_includes/schema/components/wrap_start.html` and `_includes/schema/components/wrap_end.html`. These are the files that are included in the schema pages.

#### homepageUrl
The homepageUrl preset displays a duo of fields, one for the english and the other for the french homepage URL of the current project. This preset was created since at least two of the forms made use of a homepage URL.

This preset takes no additional parameters.
```yaml
  - preset: homepageUrl
```

#### hr
The hr preset is a simple `<hr>` tag, but was created to specify sections in which the fields could be auto-completed when using a select input. For instance, in the Open Source Software form, selecting an already existing project would fill its information, leaving the user to fill only the remaining part of selecting their administration and updating its uses.

This preset takes no additional parameters.
```yaml
  - preset: hr
```

This preset does not appear in the schema.

#### Languages
The languages preset displays a list of check boxes, allowing the user to select programming languages associated to the current project. It also allows the user to add other programming languages that are not listed. This preset was created since its html markup differed from the other components and widgets.

This preset takes no additional parameters.
```yaml
  - preset: languages
```

#### Licence
The licence preset displays two fields for the licence URLs (for english and french URLs) and a field for the spdxID of the licence. The label for the spdxID contains a link to a list and definition of spdxIDs.

This preset takes no additional parameters.
```yaml
  - preset: licence
```

#### newAdmin
The newAdmin preset has two roles. In the administration standalone form, it displays all the required fields to create a new administration. In any other form, it comes with the **adminCode** preset and appears only when the user clicks on the "add a new administration" button.

This preset contains five fields.
 - A select field for the administration's level of government(locked to municipal and aboriginal)
 - A field for the code of the new administration
 - A select field for the corresponding province
 - Two fields for both the english and french names of the new administration

This preset takes one *optional* parameter:
 - `optional`: Distinguish between the standalone version of the form, or the included hidden by default version that is added with the **adminCode** preset.
```yaml
---

id:  admin

formGroups:
  - preset:  newAdmin

# _data/forms/config-admin.yml
```
OR
```html
{%- include  form/presets/newAdmin.html  id=include.id  optional=true  -%}
<!-- _includes/form/presets/adminCode.html -->
```

#### orgLevel
The orgLevel preset displays a single `<select>` widget with the different level of government (federal, provincial, municipal, aboriginal) where the "federal" and "provincial" values are disabled, since there can't be any new provinces or federal administrations.

This preset takes no additional parameters.
```yaml
  - preset: orgLevel
```

#### provinceSelect
The provinceSelect preset displays a single `<select>` widget with the list of all provinces and territories of Canada.

This preset takes no additional parameters.
```yaml
  - preset: provinceSelect
```

#### relatedCode
The relatedCode preset displays four fields:
 - The URLs (english and french) of the related code
 - The Names (english and french) of the related code

This preset takes no additional parameters.
```yaml
  - preset: relatedCode
```

#### schemaVersion
The schemaVersion preset displays a read-only field for the schema version, currently at "1.0". It should be added to each form.

This preset takes no additional parameters.
```yaml
  - preset: schemaVersion
```

#### selectCode, selectOss and selectStandard
The selectCode, as well as selectOss and selectStandard presets display a `<select>` widget allowing the user to select an already existing project in order to edit it or add a new linked element (releases, uses, administrations, etc.). Using JavaScript, the whole point of these presets are to auto-fill the corresponding section of the form when selecting an existing project.

These do not show in the schema pages. Their only use is to allow an auto-fill feature.

This follows a similar principle as the **adminCode** preset.

These presets take no additional parameters.
```yaml
  - preset: selectCode
```

#### status
The status preset displays a `<select>` input with the possible project status (Alpha, Beta, Maintained, Deprecated or Retired). It was created since at least two or more form used it.

This preset takes no additional parameters.
```yaml
  - preset: status
```

#### submitter
The submitter preset displays a separated section of the form asking for the user contact information (name, email address), in order to keep track of who submitted the form.

The submitter preset shouldn't be added in the config files since it's already included in the form layout. See the section about the form layout for more information.

#### tags
The tags preset displays fields for adding tags to the current project. There are sections for both english and french tags, as well as a button to add more tags, other than the first required one.

This preset takes no additional parameters.
```yaml
  - preset: tags
```

### Creating a new preset
The steps to creating a new preset are presented below. But first, check whether this new preset is really necessary. As explained in the presets description, they should be created only when a certain form component appears in more than one form or when a certain form component does not follow the simple markup of any other widget. However, for the new structure or markup that appears more than once, creating a more generic widget instead might also be beneficial, and hence, more reflection is necessary to make the best decision.

#### Add your new preset in the form components
Under `_includes/form/presets/`, create a file for your new preset. Its name should follow the camelCase convention. Fill it with html markup. Inspiration from other presets would help. Don't be afraid to simply include widgets in it using specific parameters, that's how most presets work when they are used in more than one form.

Then, add a call to your new preset in the form loop (`_includes/form/loop.html`) under `{%- case formGroup.preset -%}`. Follow an alphabetical order to simplify search and match the display in the folders. In the following example, change `[preset]` for the name of your new preset:
```html
{%- if formGroup.preset -%}
  {%- case formGroup.preset  -%}
    {%- when '[preset]' -%}
      {%- include form/presets/[preset].html id=idPreset [parameter=formGroup.value] -%}
```
Few notes to keep in mind:
- Keep the `id=idPreset` parameter and value intact since they will be used for the translations.
- Remove `[parameter=formGroup.value]` if you don't need to specify other parameters (this is usually the case). You can also replace it with your own custom parameter, where `value` has the same value as what you will add in the config file, and, for the sake of consistency, `parameter` should also match `value`. The `formGroup` parameter is simply the name given to each iterated element in the loop (`for formGroup in formGroups`). For example:
```html
{%- when 'example' -%}
  {%- include form/presets/example.html id=idPreset test=formGroup.test -%}
```
AND
```yaml
  - preset: example
    test: myValue
```
The value for `test` can then be accessed in your preset as `include.test`. In fact, include is the keyword used to access parameters declared in any file under the `_includes/` folder. Note that the same is true for `page.test` in `_pages/`. However, data is a bit different here as it requires first a call to site `site.data.test` where "test" can be a file or a folder in `_data/`.

#### Add your new preset in the schema components
Under `_includes/schema/presets/`, create a file for your new preset. Its name should match the one you previously created in the form folder. To fill it, follow the same advice as for the form.

Then, add it to the schema loop (`_includes/schema/loop.html`) using the same indications as for the form.

Unless your preset has a different behaviour between the form and the schema (like the empty, hr or selectCode presets), you should always create the preset file in both the form and schema folders. If your preset doesn't have the same behaviour, add its case `{%- when  'example'  -%}` to both loops but keep the case content empty. That way, you will avoid throwing errors.

### Widgets
Found under `_includes/[form/schema]/widgets/`, widgets are generic components that take more parameters and thus can be configured to fit different sections of a form.

Example: Widget with default values
```yaml
  - widget: example  # enum()
    title: ~
    type: text  # enum()
    rule: ~  # enum()
    required: true  # bool
```
In this example,
 - `widget`: specifies which widget to include. This parameter is **required**, otherwise the form will display an error message.
 - `title`: the title of the widget. Must be unique for every widget (exception applies for some available widgets). This parameter is **required**, otherwise the widget won't display any text. It is also used for translations, so its value should be the same as the corresponding element in the schema page. Further information is presented in the translation section.

> The title parameters corresponds to the id used in the translation file (`_data/i18n/form.yml`), as a second-level element under the first-level element corresponding to the id of the form declared at the beginning of the config file.
> ```yaml
> example:  # The id of the form
>   title:  # The title of the widget
>       [...]
>   ```
>   More on translations can be found in the translations section.
 - `type`: defines the input type. Available values are the appropriate values for an html input tag (text, URL, email, etc.) included in a way similar as `<input type="{{ widget.type }}">`. This widget is *optional* and defaults to "text".
 - `rule`: specifies a custom rule of validation. Available rules can be found in `_data/forms/rules.yml`. You can use any of the key (`key: value`) you may find in this document as a value for the rule parameter. This parameter is *optional* and defaults to none.
> The custom rules allows different types of validation which allows or forbids different characters in the fields. Check `assets/js/src/custom-form-validation.js` to see the full list of rules and their accepted characters.
- `required`: specifies if the field(s) in the widget is(are) required or not. This field is *optional* since all fields are required by default. Specify this parameter only when you wish to indicate that a widget should not be required.

The following sections explain each of the available widgets:
 - group
 - select
 - string-i18n
 - string

#### group
The group widget displays a list of other widgets under a single title.

This widget takes one additional parameter, in addition to the ones available to widgets.
 - `fields`: an array of widgets and their own parameters to display in the same logical group.
```yaml
  - widget: group
    title: example
    fields:
      - widget: string
        title: test1
      - widget: string-i18n
        title: test2
      [...]
```
The widget declaration under "fields" acts the same way as if they were declared as top-level fieldGroups.

Also, if you add the required parameter to the group widget, it will apply automatically to all of its children, unless specified otherwise at the child's level. The following example shows how the required parameter can be used:
```yaml
  - widget: group
    title: example
    required: false
    fields:
      - widget: string
        title: test1
        required: true
      - widget: string-i18n
        title: test2
```
In this example, the `required: false` of the parent `group` overwrites the default required value of all its widgets children, so in this example, the `string-i18n` widget would not be required. However, it would still be required in the case of the `string` widget since we specified it directly. The following example shows another way on how the required parameter can be used:
```yaml
  - widget: group
    title: example
    fields:
      - widget: string
        title: test1
        required: false
      - widget: string-i18n
        title: test2
```
In this example, since the required parameter is not specified on the `group` level, all the children are required by default. However, specifying the required parameter on a child has the same behaviour as usual, meaning that, in this case, the `string` child widget, and only this one, would not be required.

*NOTE*: It is not possible to add presets to group widgets.

#### select
The select widget was created in order to have a more generic version of a `<select>` tag. However, all select widgets were later transformed to presets, as we discovered they were used in more than one form. Currently, the select widget is not used, but since it's already built, I decided to keep it in.

This widget takes one additional parameter in addition to the ones available to widgets.
 - `options`: a list of the options available as an array.
```yaml
  - widget: select
    title: example
    options: [a, b, c]
```
The options values in the array would be also used in the value attribute of the option tag (`<option value="{{ option[i] }}"`). These options are also the keys used for the translations. For further information, check the translation section.

#### string-i18n
The string-i18n widget displays two fields for a single value (in english and french).

This widget takes all the parameters available to widgets.
```yaml
  - widget: string-i18n
    title: example
```
This widget takes also an additional parameter that was added to fix a duplicate id error in the html markup.
 - `prepend`: A string to prepend to the id when generating the html markup. It allows to keep the title parameter clear (since it's used in the schema as well as for translations) without creating conflicts in ids.

#### string
The string widget displays a single field for values that are unique and don't need translating.

This widget takes all the parameters available to widgets.
```yaml
  - widget: string
    title: example
```

### Creating a new Widget
Creating a widget is similar to creating a preset, but follows a more generic idea. Create a new widget only when multiple form components follow the same basic structure. A widget shouldn't be complex and should allow for more variations than the presets.

#### Add your new widget in the form components
Under `_includes/form/widgets/`, create a file for your new widget. Its name should follow camelCase convention. Fill it with html markup, use inspiration from other widgets, and, if possible, include components in it instead of adding new code.

Then, add a call to your new widget in the form loop (`_includes/form/loop.html`) under `{%- case formGroup.widget -%}`. Follow an alphabetical order to simplify the search process and match the display in the folders. In the following example, change `[example]` for the name of your new widget:
```html
{%- else -%}
  {%- case formGroup.widget -%}
    {%- when '[example]' -%}
      {%- include form/widgets/[example].html id=id title=formGroup.title type=formGroup.type rule=formGroup.rule required=formGroup.required [parameter=formGroup.value] -%}
        [...]
```
*Don't forget to add the default widget parameters.*

Remove `[parameter=formGroup.value]` if you don't need to specify other parameters, or replace it with your own custom parameters, where `value` has the same value as what you will add in the config file, and, for the sake of consistency, `parameter` should also match `value`.  The `formGroup` is simply the name given to each iterated element in the loop (`for formGroup in formGroups`). For example:
```html
{%- when  'example'  -%}
  {%- include form/presets/example.html [default parameters] test=formGroup.test -%}
```
AND
```yaml
  - widget: example
    test: myValue
```
The value of `test` can then be accessed in your widget as `include.test`.

> Include is the keyword used to access parameters declared in any files under the `_includes/` folder. The same is true for `page.test` in `_pages/`. Data is a bit different as it requires first a call to site `site.data.test` where "test" can be a file or a folder in `_data/`.

#### Add your new widget in the schema components
Under `_includes/schema/widgets/`, create a file for your new widget. Its name should match the one you previously created in the form folder. To fill it, follow the same advice as for the form.

Then, add it to the schema loop (`_includes/schema/loop.html`) using the same indications as for the form.

Unless your widget has a different behaviour between the form and the schema, you should always create the widget file in both the form and schema folders. If your widget doesn't have the same behaviour, add its case `{%- when 'example' -%}` to both loops, but keep the case content empty. That way, you  will avoid throwing errors.

## Includes

### The loop
Both loops act the same way. Basically, for each element in the `formGroups` array in the config file, the loop checks if the current element is a preset or a widget and a switch case checks the type of each preset or widget that is found. The loops includes then the correct file and passes the file's parameters either from the config file or directly in the include call.

The for loop goes like this: `{%- for formGroup in site.data.forms[page.config].formGroups -%}`. The "in" part is a liquid call that includes the content of the include file into the file where the include call is made: `site.data` is equivalent to requiring the `_data/` folder; forms is a call to the `forms` folder under data, linking to `_data/forms/`; and `[page.config]` is a call to the page parameter added to the page header.
```yaml
---
[...]
config: config-example
```
So `[page.config]` translates to, in this case, `config-example`, which will concatenate to `_data/forms/config-example.yml`. Not only you can mix folders and files at the same time, but also mix in parameters from inside files through `formGroups`: the `formGroup` parameter in `_data/forms/config-example.yml`.

### Components
Components are even more generic than widgets. They were created solely for the purpose of less duplication of code.

>If you don't need to debug, you can skip this section and go directly to translations.

## Translations
Translations for the form and schema pages are located in `_data/i18n/form.yml`. They are separated in sections for more generic translations and in first-level groups for each of the forms.

#### Yaml Variables
In general, you can create variables in Yaml files:
- Use `&variable` for instantiation, where *variable* represents the name of the variable you wish to create
- Use `*variable` when you intend to use the variable

In this particular project, variables are created to declare and to use generic values (name, email, URL, etc.). But the neat thing is that it can act as a string or as an object, so we can easily wrap translations inside a single variable. Here's an example of what it looks like in the files:
```yaml
name: &name
  en: Name
  fr: Nom
[...]
example:
  label: *name
```
It is equivalent to:
```yaml
example:
  label:
    en: Name
    fr: Nom
```
But without translation duplication.

### Presets
All the presets translations are already included. When modifying  any of the presets files (`_includes/[form/schema]/presets/`), you should also check the translations.

When creating a new preset, it should be added under the presets first-level group, unless you specified a different parameter in the loop (`includes/[form/schema]/loop.html`).

 - In general, when including the file, the preset ID is specified to "presets": `{% include file.yml id=idPreset %}`
 - However, you can use the variable `id` instead of `idPreset` when you intend to use the ID that is defined in the config page. This means that you should put the translations under the equivalent first-level element named after the `id` instead of the text "preset".

### Translations for Widgets
Here's how to translate widgets:
 - For each widget, add a second-level element (under the first-level named after `id`). Its name should be the same as the value you put under `title` in the config file. The title should be the same as the value in the schema page since it's included as is in the schema page.
```yaml
first-level:  # either preset, admin, code, oss, standard, etc...
  example:  # replace example with the title value of the widget
    [...]
```
 - You will also need to add a title element under it. Don't mistaken it for the second-level element, where title should be replaced with the title value of the current widget. This title is a third-level element named title which will hold the english and french value for the title. This value appears in the form page as a section's title and as the section description in the schema page:
```yaml
first-level:
  example:
    title:
      en: Example
      fr: Exemple
```
Each widget has also other specific elements that need to be added. The following sections describe each of theses elements.

#### String Widget
For a string widget, follow this template:
```yaml
first-level:
  example:
    title:
      en: Example
      fr: Exemple
    label:
      en: The english label
      fr: The french label
```

#### String-i18n Widget
For a string-i18n widget, follow this template:
```yaml
first-level:
  example:
    title:
      en: Example
      fr: Exemple
    labels:
      en:
        en: The english label for the english page
        fr: The french label for the english page
      fr:
        en: The english label for the french page
        fr: The french label for the french page
      schema:
        en: The generic english label for the schema (without specificity for either english of french)
        fr: The generic french label for the schema (without specificity for either english of french)
```

#### Select
For a select widget, follow this template:
```yaml
first-level:
    example:
      title:
        en: Example
        fr: Exemple
      options:
        option-name:  # where option-name is the value added in the options array in the config file
          en: Option
          fr: Option
        [...]
```
#### Group
For a group widget, the values under `labels` depends on the fields' widget type. Follow this template:
```yaml
first-level:
  title:
    en: Example
    fr: Exemple
  labels:
    string:  # replace string with the title of a string widget
      en: The english value for the label
      fr: The french value for the label
    string-i18n:  # replace string-i18n with the title of a string-i18n widget
      en:
        en: The english value for the english page
        fr: Then french value for the english page
      fr:
        en: The english value for the french page
        fr: The french value for the french page
  titles:
    widget-name:  # replace widget-name with each widget names
                  # The title is used for the schema page
      en: Widget Name
      fr: Nom du widget
    [...]
```

## JavaScript
Each form needs its own custom JavaScript which you will have to create.

All the scripts are located under `assets/js/src/`. The scripts for each form follows the naming convention `[form id]Form.js` with camelCase. There are other scripts that fall under the utility category:
- `programmingLanguages.js` for adding and removing custom programming languages in the preset of the same name
-  `tags.js` for adding and removing tags in the tags preset

### Footer links
Links to the scripts are added in the footer located in `_includes/footer.html`.

At the very bottom, there's an inline script declaring some constants that are used in other script files: `REPO_NAME`, `USERNAME`, and `PRBOT_URL` . Their values are taken from the `_config.yml` and pulled through Jekyll/Liquid. The scripts for the forms are added right above that inline script. Up next, we add the script only on its particular form page with a simple `if` using the page `ref` (declared in the page header).

### PRB0T
[PRB0T](https://github.com/PRB0t/PRB0t) is an open source solution we [forked](https://github.com/j-rewerts/PRB0t) and customized to fit our specific needs. It was used with the forms in order to submit changes. Basically, we merge the necessary files with the new content pulled from the form, and then we submit a pull request in the Github repo.

### Javascript files
At the beginning of the file, there's a comment that tells ESLint that the function does exist but in another file. Hence, it won't throw errors or fail the build.

Two javascript objects are then declared constants. Since they're used all through the file, it made sense to declare them only once at the top.

There's also the jQuery, the equivalent of `document.ready`, in which we added the function binding between different selects for auto-fill, the submit and reset for the form.

#### Submit
When submitting the form, we first validate the form and initiate the alerts. We continue only once it's validated using the `submitInit()` function from the `validation.js`.

#### Reset
Some forms require a specific function for reset, especially when dealing with tags and programming languages.  The user is able to add and remove tag fields and we want to make sure to reset those fields since the basic reset does not take care of that by default.

#### getObject
The `get[form id]Object()` function takes all the values from the form inputs and assigns them to an object variable. That object follows the hierarchy as the schema for the form. It is separated into two sections. First, all mandatory fields are added to the object. Then, the function probes each single non-mandatory field, checking whether it has a value or not. In case it has a value, the non-mandatory field is added to the object. That way, no keys with empty values will be added to the data files.

#### addValuesToFields / resetFields
When the user selects an already existing project or administration, data is pulled from github. The addValuesToFields fills some input fields with the fetched data. Now if the user chooses to change back the select to its default null value, the resetField removes the values that were added automatically to the input fields from fetched data.
In both cases, not all form fields are modified automatically: in the open software form, selecting an existing software and selecting an existing administration do not auto-fill the same fields, and resetting one select does not mean that the other select also needs resetting.

# Solution pour générer automatiquement les formulaires et leurs schémas. (Français)

Inspiré des principes de base de [Netlify Cms](https://www.netlifycms.org/), ce système a été mis en place afin de mieux répondre aux caractéristiques de ce projet.

Cette documentation a pour objectif d'expliquer comment générer automatiquement des pages de formulaires et de schémas à partir des données d'un fichier `yml`, tout en respectant le layout des pages et les traductions du dossier `_data/il8n`. Il existe cependant une limite logique à cette automatisation et l'utilisation de scripts (JavaScript) demeure nécessaire au bon fonctionnement du formulaire.

Ce document explique comment les éléments de la solution fonctionnent. Il contient également des instructions sur comment les utiliser, comment les mettre à jour et comment en créer de nouveaux.

## Pages

Pour assurer la récupération de toutes les données à configurer, les pages doivent suivre un certain modèle qui sera présenté dans cette section. Vous trouverez les pages dans le dossier `_pages/`.

**ATTENTION** : Lorsque des pages sont créées ou mises à jour, assurez-vous d'appliquer les changements dans les deux langues! Vous trouverez les pages correspondantes dans les dossiers `_pages/en` et `_pages/fr`. Cherchez les pages ayant une même valeur pour le paramètre `ref` dans leurs entêtes.

Les variables à inclure au niveau de l'entête des pages sont présentées ci-dessous. Celles-ci devraient être incluses dans tout formulaire et schéma (un exemple suivra).

- `layout` : définie la structure de mise en page à suivre. Par défaut, cette variable a pour valeur "default". Les layouts sont situées dans le dossier `_layouts/`.

- `ref` : il s'agit d'un ID unique qui différencie entre les différentes pages. Cependant une page en français aura un même ID que sa page équivalente en anglais et vice-versa, permettant ainsi la redirection des pages web au moment où un changement de langue est effectué.

> Comment `ref` est utilisé ? En changeant la langue de la page, cette dernière est générée en utilisant Jekyll/Liquid. Une recherche est lancée afin de trouver les pages ayant une même valeur pour `ref` que la page courante, mais une valeur différente pour `lang`. Une fois repérées, les liens électroniques des pages trouvées seront ajoutés à la barre de navigation du sélecteur de langue (*"language switcher navbar"*).

- `lang` : correspond à la langue associée à la page. Utilisée le plus souvent comme `[page.lang]`, cette variable permet de sélectionner la bonne valeur pour une traduction. Les valeurs acceptés sont `en` et `fr`.
> Chaque traduction doit suivre le modèle suivant:
> ```yaml
> exemple:
>    en: Valeur page en anglais
>    fr: Valeur page en français
>    ```
> Ainsi, pour la traduction du mot-clé "exemple", la syntaxe ``{{ exemple[page.lang] }} `` est utilisée. À noter que ``[page.lang]`` peut être utilisée quelque soit la langue de la page courante, d'où l'avantage de cette syntaxe. Elle permet aussi d'utiliser "include" en évitant la duplication pour chaque langue, sachant que les variables d'une page s'appliquent pour toutes les composantes de la page.

- `permalink` : correspond au permalien de la page (au moins la partie qui sera ajoutée au URL de base du site) qui remplacera l'emplacement du fichier dans les dossiers lorsque le site internet sera compilé. Suivre la convention suivante `/[lang]/[page name]`.

**Exemple d'entête pour une page normale**
```yaml
---
layout: default
ref: exemple
lang: fr
permalink: /fr/exemple.html
---
```

### Page de formulaire
Les pages de formulaire nécessitent les ajustements suivants au niveau des variables :
- `layout` : les pages de formulaire ont la valeur `form` par défaut pour la variable `layout`au lieu de la valeur `default`.
- `Config` : correspond au nom du fichier Yaml dans le dossier `_data/forms/` qui est associé au formulaire actuel. Ainsi, la relation entre le layout actuel et les données requises pour le formulaire est créée.

**Exemple d'entête pour une page de formulaire**
```yaml
---
layout: form
ref: exempleForm
lang: fr
permalink: /fr/exemple-form.html
config: exemple-config  # Ira chercher _data/forms/config-example.yml
---
```
### Page de schéma
Les pages de schéma possèdent les même variables d'entête que les formulaires, mais plutôt, la valeur "schema" serait définie pour le paramètre `layout`. De plus, la page de formulaire et la page de schéma qui sont associées l'une à l'autre doivent avoir une même valeur pour le paramètre `config` pour permettre l'extraction des mêmes données.

**Exemple d'entête pour une page de schéma**
```yaml
---
layout: schema
ref: exempleSchema
lang: fr
permalink: /fr/exemple-schema.html
config: exemple-config
---
```

## Layouts

Les pages de schéma et de formulaire suivent toujours les mêmes *layouts*: le *form layout* et le *schema layout*. Cette forme permet d'ajouter tout contenu spécifique à la page en question. Ces derniers se comportent comme un gabarit ou une mise en page où les données extraites du fichier *config* seront ajoutées.

### *Form layout*
Situé dans le dossier `_layouts/form.html`, il hérite du *layout* par défaut pour inclure l'entête, le bas de page et d'autres composantes fixes du site web.

#### Comment ça marche

Tout d'abord, le contenu de la page est ajouté au *layout* via la ligne de code `{{ page.content }}`.
Par la suite, se trouve le *form tag*. Celui-ci comprend:
- Les *classes* et les *id* nécessaire pour le *plugin* de validation du formulaire (provient avec le modèle [WET-BOEW](https://wet-boew.github.io/wet-boew/docs/ref/formvalid/formvalid-en.html)).
- La définition de la variable `idPresets`. Elle fait directement référence au groupe de premier niveau *presets* dans le fichier de traduction. Cette variable a été déclarée une seule fois pour les formulaires pour éviter de dupliquer cette même définition.
- La "pièce de résistance": un appel à la boucle du formulaire (`loop.html`), permettant de chercher les valeurs dans le fichier *config* et de les ajouter au formulaire, grâce à la fonctionnalité `include`.
- Un second *include call* (juste après l'appel de la boucle) afin d'inclure le fichier du *submitter*. Les informations de l'auteur d'un formulaire sont nécessaires pour la création de *pull requests* afin de préserver une trace de l'auteur en question.
- Les boutons *submit* et *reset*. Il est à noter que le bouton *submit* a un id unique correspondant à `prbotSubmit{{ page.ref }}` où `{{ page.ref }}` fait référence à la valeur du paramètre `ref` dans l'en-tête de la page.

Ces éléments ne sont ni dans la page même ni dans le fichier *config*. On les retrouve plutôt dans le *layout* sachant qu'ils doivent tous apparaître dans la page du formulaire quelque soit le formulaire auquel la page refère.

### Layout de schéma

Situé dans le dossier `_layouts/schema.html`, il hérite du "layout" par défaut pour inclure l'en-tête, le bas de page ainsi que d'autres composantes fixes du site web.

#### Comment ça marche

Tout d'abord, le contenu de la page est ajouté au *layout* via la ligne de code `{{ page.content }}`. Cette forme permet d'ajouter tout contenu spécifique à la page en question. Par la suite, hormis la boucle du schéma rien n'est ajouté.

## Fichiers *config*

Ces fichiers représentent le cerveau de la solution. Ils spécifient chaque composant ainsi que leurs paramètres devant être inclus dans le formulaire et son schéma correspondant.

**Voici un exemple de fichier avec les valeurs par défaut:**
- `~` représente une valeur par défaut indéfinie
- Chaque valeur assignée à un paramètre est une chaîne de caractères ou un *string* en anglais (sauf par preuve du contraire)
  - `# enum()` indique que le champs n'accepte que certaines valeurs spécifiques

Note: Les "presets" et "widgets" disponibles, ainsi que leurs paramètres, seront présentés après cet exemple, dans leurs sections réservées
```yaml
---

id: exemple
formGroups:
  - preset:  ~  # enum()
  - widget: ~  # enum()
    title: ~
    type: text
    rule: ~  # enum()
    required: true  # bool
```
### Presets
Situé sous le dossier `_includes/[form/schema]/presets/`, les *presets* représentent des sections statiques contenant un ensemble de paramètres prédéfinis. L'ajout de paramètres est rarement nécessaire pour ces sections. Les *preset* sont créés dans une des situations suivantes:

- lorsqu'une section est présente dans plusieurs formulaires, dans le but de réduire la duplication de code
- lorsqu'une section est très spécifique et que les widgets déjà présents ne permettent pas sa création. Ceci est le cas si les modifications spécifiques ne peuvent pas être ajoutés en temps que paramètres, ou si le format correspondant est différent de tous les widgets déjà présents.

Voici une liste des *presets* disponibles :
- adminCode
- contact
- dates
- description
- empty
- homepageURL
- hr
- languages
- licence
- newAdmin
- orgLevel
- provinceSelect
- relatedCode
- selectCode, selectOss et selectStandard
- status
- submitter
- tags

Les sections suivantes présentent une explication de chacun des *presets* disponibles.

#### AdminCode
L'*adminCode* affiche un menu de sélection (`<select>` widget) pour les administrations. Celles-ci sont séparées par groupe selon le niveau de gouvernement: fédéral, provincial, municipal et autochtone. La liste des administrations se trouve sous le dossier suivant: `_data/administrations/[level of gov.].yml`.

Le menu est suivi d'un bouton permettant à l'utilisateurs de créer une nouvelle administration au cas où son administration n'était pas déjà présente dans liste. Une nouvelle section est alors ouverte dans le formulaire et des champs obligatoires sont à remplir. Consultez la section **newAdmin** de la documentation pour de l'information sur ces champs.

Lorsqu'une administration est sélectionnée, du JavaScript est utilisé pour remplir automatiquement la section de de l'administration du formulaire, dépendamment de son type. La même logique est suivie pour les *presets* **selectCode**, **selectOss** et **selectStandard**.

L'adminCode ne prend pas de paramètres additionnels:

```yaml
  - preset: adminCode
```
#### Contact
Ce *preset* affiche un ensemble de champs relatif aux coordonnées de la personne (ou de l'organisation) à contacter pour des informations générales sur le projet ouvert auquel le formulaire fait référence.

Ce *preset* accepte un seul et unique paramètre (celui-ci est **optionnel** ) selon le type de formulaire :
- `phone`: Paramètre booléen permettant de savoir si ce champ (phone/téléphone) devrait être ajouté. Sa valeur par défaut est `true`.
```yaml
  - preset: contact
    phone: tru  #bool
```
#### Dates
Ce *preset* représente un groupe de champs relatif aux dates pertinentes du projet: *date de création*, *dernière modification* et *dernière mise à jour*.

Ce *preset* nécessite trois paramètres **obligatoires** (param. booléen):

- `created`: Spécifie s'il est nécessaire de définir la date de création.
- `started`: Spécifie s'il est nécessaire de définir la date de début.
- `modified`: Spécifie s'il est nécessaire de définir la date de la dernière modification.
```yaml
  - preset: dates
    created: false  #bool
    started: false  #bool
    modified: false  #bool
```
À noter que le groupe des dates serait vide au cas ces paramètres n'étaient pas définis, à l'exception de la date de dernière modification: ce paramètre est inclus par défaut et sa valeur correspond à la date de soumission du formulaire.
Pour optimiser le nombre de lignes de code, vous pouvez définir uniquement les paramètres que vous désirez afficher en leur attribuant la valeur `true`:
```yaml
  - preset: dates
    created: true
    modified: true
 ```

#### Description
La *description* regroupe deux champs: un champ pour la description en anglais et un second pour la description en français.

Ce *preset* ne prend pas de paramètres additionnels.
```yaml
  - preset: description
```

#### Empty
Ce *preset* n'affiche rien dans le formulaire. Celui-ci permet d'adapter la structure de données d'un formulaire afin qu'il corresponde à la structure d'un schéma. Par exemple, pour la structure de données du schéma du *release* (`_data/schemaCode.yaml`), il ne ferait pas de sens de changer complètement le *layout* du formulaire pour l'adapter à ce schéma sachant qu'un seul *release* peut être mis à jour à la fois.

Ce *preset* prend deux paramètre **obligatoires**:

- `start`: Définit s'il s'agit du début ou de la fin de la structure de données dans le schéma.
- `title`: Nom de la structure de donnée dans le schéma (également utilisé pour les traductions, voir la section des *widgets* pour plus d'informations).
```yaml
  - preset: empty
    start: false  # bool
    title: exemple
# Beginning a group / array
```
OU
```yaml
  - preset: empty
# Closing a group / array
```
Les balises de début et de fin sont situées dans les dossiers suivants: `_includes/schema/components/wrap_start.html` et `_includes/schema/components/wrap_end.html`. Ce sont les fichiers incluent dans les pages de **schéma**.

#### HomepageUrl
Ce *preset* affiche deux champs pour les deux langues, soit EN et FR. Chaque champ correspond à l'URL de la page d’accueil (pour chaque langue).
Ce *preset* ne prend pas de paramètres additionnels.
```yaml
  - preset: homepageUrl
```
#### HR
Ce *preset* a été mis en place afin d'identifier les sections dont les champs peuvent se remplir automatiquement dépendamment de l'entrée. Par exemple, dans le formulaire pour les OSS, la sélection d'un projet existant remplira automatiquement les champs déjà enregistrés (l'utilisateur n'aura qu'à compléter les parties manquantes)

**NOTE** : Ce *preset* n’apparaît pas dans le schéma et ne prend pas de paramètres additionnels.
```yaml
  - preset: hr
```
#### Languages
Ce *preset* permet d'afficher une liste de langages de programmation à sélectionner (l'utilisateur sélectionner ceux étant associé à son projet). De plus, celui-ci permet à un quelconque utilisateur d'ajouter son propre langage s'il ne le trouve pas dans la liste.

Ce *preset* ne prend pas de paramètres additionnels.
```yaml
  - preset: languages
```
#### Licence

Ce *preset* affiche deux zones de texte pour l'URL des licences selon chaque langue, soit EN et FR. On retrouve également un autre champ pour le spdxID de la licence. Le *label* pour le spdxID contient un lien vers une liste et définition de spdxID (juste au-dessus de la zone de texte).
Ce *preset* ne prend pas de paramètres additionnels.
```yaml
  - preset: licence
```

#### NewAdmin

Le *preset* *newAdmin* occupe deux rôles:

- Pour le formulaire d'administrations autonomes, celui-ci permet d'afficher tout les champs nécessaires à la création d'une nouvelle administration.
- Pour tous les autres formulaires, il affiche les champs requis seulement lorsque l'utilisateur clique sur le bouton ***Nouvelle administration*** (vient avec le *preset* adminCode).

Ce *preset* regroupe 5 champs:
- Un champs de sélection pour le niveau de l'organisation.
- Un champ pour le code de la nouvelle administration.
- Un champs de sélection pour la province de l'administration.
- Deux derniers champs pour le nom français et anglais de l'administration.

Ce *preset* accepte un seul et unique paramètre (celui-ci est **optionnel**) :
- `optional`: Permet de faire la distinction avec le formulaire d'administrations autonomes.

```yaml
---
id: admin
formGroups:
  - preset: newAdmin
# _data/forms/config-admin.yml
```
OU
```html
{%- include form/presets/newAdmin.html id=include.id optional=true -%}
<!-- _includes/form/presets/adminCode.html -->
```
#### OrgLevel
L'*orgLevel* affiche un *widget*, soit un menu de sélection (`<select>` pour le tag HTML utilisé), pour les différents niveaux de gouvernement, soit fédéral, provincial, municipal, etc. Le niveau fédéral et le niveau provincial sont bloqués, car il ne peut pas y avoir de nouvelles provinces ou de nouvelles administrations fédérales.

Ce *preset* ne prend pas de paramètres additionnels.
```yaml
  - preset: orgLevel
```

#### ProvinceSelect
Affiche un menu de sélection (un *widget*) renfermant une liste de tous les territoires et provinces du Canada.

Ce *preset* ne prend pas de paramètres additionnels.

```yaml
  - preset: provinceSelect
```

#### RelatedCode
Ce *preset* affiche 4 champs:
- Les URL (FR et EN) relatifs au code.
- Les noms (FR et EN) relatifs au code.

Il ne prend pas de paramètres additionnels.

```yaml
  - preset: relatedCode
```
#### SchemaVersion
Le *schemaVersion* affiche un champ *readonly* (zone de texte de lecture) concernant la version actuelle du schéma (actuellement à 1.0).

**NOTE** : Ce *preset* devrait être ajouté pour chaque formulaire.

Il ne prend pas de paramètres additionnels.
```yaml
  - preset: schemaVersion
```

#### SelectCode, selectOss et selectStandard
Ces trois *presets* affichent un menu de sélection (un *widget*) permettant à un quelconque utilisateur de sélectionner un projet (déjà existant) afin de le modifier ou bien d'y ajouter des éléments lui étant reliés (administrations, etc.). Ils permettent **principalement** de remplir automatiquement la section correspondante du formulaire lorsqu'un projet est sélectionner grâce au JavaScript (ils suivent le même principe que l'*adminCode*).

Ces trois *presets* ne prennent pas de paramètres supplémentaires.

```yaml
  - preset: selectCode
```
#### Statuts
Ce *preset* affiche un `<select>` *input* correspondant aux possible statuts du projet (*alpha*, *bêta*, maintenu, déprécie ou retraité).

Il ne prend pas de paramètres additionnels.
```yaml
  - preset: status
```

#### Submitter
Affiche une section séparée du formulaire demandant à l'utilisateur ses informations (nom et email) afin de garder une note de celui qui a soumis le formulaire.

**NOTE** : Il n'est pas nécessaire d'inclure ce *preset* dans les fichiers de configurations sachant qu'il est déjà inclus dans le *layout* du formulaire.

#### Tags
Ce *preset* affichent des champs permettant d'ajouter des tags à un quelconque projet. Il existe des sections pour l'anglais et le français.

Celui-ci ne prend pas de paramètres additionnels.
```yaml
  - preset: tags
```
### Créer un nouveau *preset*

Cette section présente les étapes relatives à la création d'un nouveau *preset* . Avant tout, assurez-vous que la création de celui-ci est réellement nécessaire. En effet, comme dit précédemment, un nouveau *preset* peut être créé lorsqu'un composant revient dans plusieurs formulaires ou lorsqu'un composant a une structure assez spécifique et ne suit aucun widget déjà présent. Cependant, pour une nouvelle structure qui est récurrente, créer un widget générique peut être avantageuse et une réflexion s'avère nécessaire pour prendre une bonne décision.

#### Ajoutez votre nouveau *preset* dans les composantes d'un formulaire
Pour commencer, créer un nouveau fichier pour votre nouveau *preset* dans le dossier `_includes/form/presets/`.  Le nom du fichier doit suivre la convention *camelCase*. Remplissez le d'un balisage HTML. N'hésitez pas d'utiliser les autres *presets* comme source d'inspiration et d'inclure alors des widgets en utilisant des paramètres spécifiques quand ils se répètent dans plusieurs formulaires.

Par la suite, faites appel à votre *preset* dans la *loop* (`_includes/form/loop.html`) sous `{%- case formGroup.preset -%}` tout en respectant l'ordre alphabétique déjà établi. Voici un exemple de l'ajout d'un nouveau *preset* dans la *loop*:
```html
{%- if formGroup.preset -%}
  {%- case formGroup.preset -%}
    {%- when '[preset]' -%}
      {%- include form/presets/[preset].html id=idPreset [parameter=formGroup.value] -%}
```
Dans cet exemple, le terme `[preset]` doit être modifié pour le nom de votre nouveau preset.

Voici quelques astuces concernant les paramètres lors de l'ajout du `preset` dans la *loop*:
- Gardez la valeur `idPreset` et le paramètre `id` intact. On veut préserver l'égalité `id=idPreset` sachant qu'ils seront utilisés lors de la traduction du formulaire.
- Enlever `parameter=formGroup.value` si vous n'avez pas besoin de définir d'autres paramètres et la modifier si vous voulez ajouter de nouveaux. À cet effet, remplacez `[value]` par votre propre valeur, qui sera ajoutée dans le dossier de configuration. Pour la cohérence, remplacez `parameter` par la même valeur attribuée à `[value]`. Quant au paramètre `formGroup`, il est simplement le nom donné pour chaque élément de la boucle `for formGroup in formGroups`. Voici un exemple illustrant cette astuce:
```html
{%- when 'example' -%}
  {%- include form/presets/example.html id=idPreset test=formGroup.test -%}
```
ET
```yaml
  - preset: example
    test: myValue
```
Vous pourriez accéder à la valeur de `test` de cet exemple dans votre *preset* en utilisant `include.test`. En effet, *Include* est le terme employé pour accéder à tous les paramètres déclarés (dans tous les fichiers) dans le dossier `_includes/`. Notez que le même principe est applicable pour `page.test`dans `_pages/`. Les données sont cependant un peu différentes et l'utilisation de `site.data.test` (où "test" désigne un fichier ou un dossier dans `_data/`) est requise.

#### Ajoutez votre nouveau *preset* dans les composantes d'un schéma

Créez un nouveau fichier pour votre *preset* dans le dossier `_includes/schema/presets/`. Son nom doit correspondre au nom du fichier déjà créé dans le dossier du formulaire. Pour remplir le fichier, suivez les recommandations développées précédemment pour l'ajout du *preset* dans les composantes du formulaire.

Ensuite, ajoutez ce fichier à la *loop* `_includes/schema/loop.html` en suivant les mêmes indications que pour le formulaire.

**Note** : La création d'un nouveau fichier dans chaque dossier, soit `_includes/schema/presets/` et `_includes/form/presets/`, est nécessaire lors de la création d'un nouveau *preset*. Une exception s'applique lorsque le comportement du *preset* diffère entre le schéma et le formulaire (le *selectCode* ou le *hr* par exemple). Dans cette situation, la création d'un fichier dans chaque dossier n'est pas obligatoire. Cependant, il faut tout de même faire appel au *preset* dans les deux *loop* en utilisant `{%- when 'example' -%}`, mais en laissant le contenu du cas (*case content*) vide pour ne pas avoir des erreurs. Le code exécuté par les deux appels sera différent.

### Widgets

Contrairement aux *presets*, les *widgets* sont des sections beaucoup plus flexibles dont l'ajout de paramètres est beaucoup plus fréquent (le nombre de paramètres est également plus élevé). Ceux-ci peuvent ainsi être configurés afin d'être mieux adaptés aux différentes sections du formulaire.

Voici un exemple de *widget* avec des valeurs par défaut:
```yaml
  - widget: example  # enum()
    title: ~
    type: text  # enum()
    rule: ~  # enum()
    required: true  # bool
```
Dans cet exemple,
- `widget` (**obligatoire**): définit le type de *widget* à inclure. Ce paramètre doit impérativement être définit, sinon, le formulaire affichera un message d'erreur.
- `title` (**obligatoire**): définit le titre du *widget*. Il est unique à chaque *widget*, à l'Exemption de quelques uns. Ce paramètre est important puisqu'il affiche le texte relatif au *widget*. La valeur associée à ce paramètre doit être identique à l'élément correspondant dans la page de schéma, afin de rendre la traduction du *widget* possible.

> Ce paramètre correspond à l'ID utiliser dans le fichier de traduction (`_data/i18n/form.yml`), comme un élément de second ordre après l'ID du formulaire déclaré au début du fichier de configuration.
> ```yaml
> example:  # L'ID du formulaire
>   title:  # Le titre du widget
> [...]
> ```
> Visitez la section sur les traductions pour plus d'informations.

- `type` (**optionnel**): définit le type d'entrée du *widget*, en utilisant `<input type="{{ widget.type }}">`. Les entrées possibles sont les valeurs de bases fournis par HTML (soit email, URL, *text*, etc.). La valeur par défaut de ce paramètre est *"text"*.
- `rule` (**optionnel**): définit les règles de validation pour une entrée quelconque. Des règles sont disponibles dans le fichier `_data/forms/rules.yml`. Vous pouvez utiliser n'importe quel *key* (`key: value`) que vous trouverez dans ce document comme valeur pour ce paramètre. Sa valeur par défaut est "*none*".

> Les règles vont par exemple interdire certains caractères pour certaines entrées, etc. Pour voir la liste complète des règles voir le fichier suivant `assets/js/src/custom-form-validation.js`.

- `required`: définit si un champs dans le *widget* est obligatoire ou pas. Par défaut, tous les champs sont obligatoires. Il faut donc spécifier lorsqu'un champ est optionnel.

Voici une liste des *widgets* disponible:
- group
- select
- string-i18n
- string

Les sections qui suivent expliquent chacun des *widgets* disponibles.

#### group
Ce widget correspond à une liste ou un groupe de *widgets*, disponible sous un seul titre. Il prend un paramètre additionnel, incluant ceux présentés précédemment:

- `fields`: il s'agit d'un tableau de *widgets* et leurs paramètres à afficher dans un même groupe logique.

Par exemple:
```yaml
- widget: group
  title: example
  fields:
    - widget: string
      title: test1
    - widget: string-i18n
      title: test2
   [...]
```
La déclaration d'un *widget* sous "*fields*" est similaire à sa déclaration comme étant un haut niveau *fieldGroup*.
La déclaration des *sous-widgets* se fait de la même façon qu'un quelconque *widget*.
Si on ajoute le paramètre `required`  au *group widget*, celui-ci s'appliquera automatiquement pour tous ses enfants, à moins d'indication différente au niveau des enfants.  Voici un exemple:
```yaml
  - widget: group
   title: example
   required: false
   fields:
    - widget: string
      title: test1
      required: true
    - widget: string-i18
      title: test2
```
Dans cet exemple, le *widget* *string-i18n* aura le même état que le *widget* parent (*group*) au niveau du paramètre `required`. Cependant, ceci ne s'applique pas au *widget* *string* puisqu'il définit lui-même l'état du paramètre `required`.

Il est possible également de définir le paramètre `required` au niveau d'un enfant, sans le définir au niveau du groupe:
```yaml
  - widget: group
    title: example
    fields:
      - widget: string
        title: test1
        required: false
      - widget: string-i18n
        title: test2
```
Dans ce cas, tous les enfants ont une valeur *"true"* par défaut pour le paramètre `required`, sauf indication contraire. Dans cet exemple, seulement le *widget* *string* ne serait pas obligatoire.

*NOTE* : Il n'est pas possible d'ajouter des *presets* à ce type de *widget*.

#### Select

Ce *widget* a été créé afin d'obtenir une version beaucoup plus générique du tag HTML `<select>`. Cependant, ce widget n'est plus utilisé dans la solution actuelle:  tous les *widgets* *select* ont été transformés en *presets* parce qu’ils étaient utilisés dans plusieurs formulaires (et donc la création d'un *preset* était une option plus favorable). Mais, il est malgré tout disponible.

Ce *widget* prend un paramètre  additionnel, incluant ceux présentés précédemment:
- `options`: un tableau contenant les options disponibles.
```yaml
  - widget: select
    title: example
    options: [a, b, c]
```
Les valeurs disponibles dans le tableau sont utilisées aussi pour la traduction (voir la section traduction pour plus d'informations). Elles peuvent aussi être utilisées pour l'attribut *value* du "tag *option*" (`<option value="{{ option[i] }}"`).

#### string-i18n

Ce *widget* affiche deux champs pour une seule valeur (français et anglais). Il prend tout les paramètres disponibles pour un *widget*.
```yaml
  - widget: string-i18n
    title: example
```
Un paramètre supplémentaire a été ajouté par la suite dans le but de corriger une erreur relative aux ID:
- `prepend`: il s'agit d'un *string* à ajouter à l 'ID lorsqu'on génère les balises HTML. Ceci permet de conserver le paramètre `title` en évitant la création de conflits entre les ID.

#### string
Ce widget affiche un champ unique pour les valeurs ne nécessitant pas de traduction. Il prend tout les paramètres disponibles pour un *widget*.
```yaml
  - widget: string
    title: example
```

### Créer un nouveau *widget*

La création d'un *widget* est très similaire à la création d'un *preset*. Créez un *widget* uniquement lorsque plusieurs composantes d'un formulaire suivent une même structure. Notons qu'un *widget* devrait être simple et plus flexible qu'un *preset* en terme d'alteration.

#### Ajoutez votre nouveau widget dans les composants du formulaire

Tout d'abord, créez un nouveau fichier pour votre *widget* dans le dossier `_includes/form/widgets/`. Le nom du fichier doit suivre la convention *camelCase*. Ajoutez-y ensuite le balisage HTML. N'hésitez pas à utiliser les autres *widgets* comme source d'inspiration et à inclure des composantes au lieu d'ajouter des nouvelles lignes de code dans la mesure du possible.

Par la suite, faites appel à votre *widget* dans la *loop* (`_includes/form/loop.html`) sous `{%- case formGroup.preset -%}` tout en respectant l'ordre alphabétique déjà établi. Voici un exemple de l'ajout d'un nouveau *widget*, nommé `[example]`, dans la *loop*:
```html
{%- else -%}
  {%- case formGroup.widget -%}
    {%- when '[example]' -%}
      {%- include form/widgets/[example].html id=id title=formGroup.title type=formGroup.type rule=formGroup.rule required=formGroup.required [parameter=formGroup.value] -%}
```
N'oubliez pas d'ajouter les paramètres par défaut du *widget*.
Voici quelques astuces concernant les paramètres lors de l'ajout du `widget` dans la *loop*:
- Si votre *widget* ne prend pas d'autres paramètres, vous pouvez ignorez l'égalité `parameter=formGroup.value`.
- Si l'ajout de d'autres paramètres est possible (comme pour le *widget group* par exemple), remplacez l'égalité par votre propre paramètre et votre propre valeur. Le paramètre `formGroup` est simplement le nom donné pour chaque élément de la boucle. Voici un exemple illustrant cette astuce:
```html
{%- when 'example' -%}
  {%- include form/presets/example.html [default parameters] test=formGroup.test -%}
```
ET
```yaml
  - widget: example
    test: myValue
```

Vous pourriez accéder à la valeur de `test` de cet exemple dans votre *preset* en utilisant `include.test`.

En effet, *Include* est le terme employé pour accéder à tous les paramètres déclarés (dans tous les fichiers) dans le dossier `_includes/`. Notez que le même principe est applicable pour `page.test`dans `_pages/`. Les données sont cependant un peu différentes et l'utilisation de `site.data.test` (où "test" désigne un fichier ou un dossier dans `_data/`) est requise.

#### Ajoutez votre nouveau *widget* dans les composantes de votre schéma

Créez un nouveau fichier pour votre *widget* dans le dossier `_includes/schema/widgets/`. Son nom doit correspondre au nom du fichier déjà créé dans le dossier du formulaire. Pour remplir le fichier, suivez les recommandations développées précédemment pour l'ajout du *widget* dans les composantes du formulaire.

Ensuite, ajoutez ce fichier à la *loop* `_includes/schema/loop.html` en suivant les mêmes indications que pour le formulaire.

**Note** : La création d'un nouveau fichier dans le dossier des formulaires et des schémas est nécessaire lors de la création d'un nouveau *preset*. Une exception s'applique lorsque le comportement du *widget* diffère entre le schéma et le formulaire. Dans cette situation, la création d'un fichier dans chaque dossier n'est pas obligatoire. Cependant, il faut tout de même faire appel au *widget* dans les deux *loop* en utilisant `{%- when 'example' -%}`, mais en laissant le contenu du cas (*case content*) vide pour ne pas avoir des erreurs.  Le code exécuté par les deux appels sera différent.

## Includes

### Les *loops*
L'objectif des boucles est de récupérer les informations relatives aux *presets* et *widgets* stockés dans le tableau `formGroups` du fichier *config*. Ainsi, les boucles parcourent le tableau en question et vérifient si l'élément courant de la boucle est un *preset* ou un *widget*. Le type du *preset* ou du *widget* est déterminé par la suite à l'aide d'un *switch case*. La boucle récupère la/les valeur(s) du/des paramètre(s) associés, à partir du fichier config ou par la fonction `include`. Elle les assigne finalement au(x) paramètre(s) correspondant(s) du *widget* ou *preset*.

**NOTE**: Les deux boucles (formulaire et schéma) agissent de la même façon.

La boucle *for* est exécutée de la façon suivante: `{%- for formGroup in site.data.forms[page.config].formGroups -%}`. En bref, elle fait appel à l'un des fichiers *config* disponibles (config-code, etc.) dépendamment de la valeur assignée au paramètre `[page.config]` de la page en cours. Si l'on suit la structure de l'appel, le paramètre spécifiant le fichier recherché se trouve sous le dossier `forms/` qui lui même se trouve sous le dossier `_data/`.
```yaml
---
[...]
config: config-example
```
Dans ce cas, `[page.config]` se traduirait par `config-example` (si l'on considère la valeur du paramètre *config* dans l'exemple) et sera concaténé à `_data/forms/` donnant ainsi `_data/forms/config-example.yml`. On remarque donc qu'il est non seulement possible de fusionner des dossiers et des fichiers (par concaténation), mais cette fonctionnalité est également possible avec les paramètres intégrés dans les fichiers via le `formGroups` (cette concaténation `_data/forms/config-example.yml` est un très bel exemple).

### *Components*

Les *components* sont beaucoup plus génériques que les *widgets* et ont été créé dans le but de diminuer la duplication de code.
> Si vous n'avez pas besoin de déboguer, vous pouvez passer cette section et aller directement à la section des traductions.

## Traductions

Les traductions pour les formulaires et schémas se trouvent dans le fichier `_data/i18n/form.yml`.

#### Variables YAML

En général, il est possible de créer des variables dans les fichiers YAML:
- Pour instancier, utilisez la syntaxe `&variable` (où *variable* représente le nom de votre variable YAML).
- Pour utiliser la variable en question, utilisez la syntaxe `*variable`.

Pour ce projet en question, la création d'une variable dans les fichiers YAML a permit de déclarer et d'utiliser des valeurs plus génériques (*name*, *email*, URL, etc.). La particularité de cette fonctionnalité est que la variable peut agir en tant que *string* ou bien en tant qu'*objet*. Ainsi, il est possible d'envelopper des traductions dans une seule variable.

Voici un exemple pouvant être retrouvé dans un quelconque fichier:
```yaml
name: &name
  en: Name
  fr: Nom
  [...]
example:
  label: *name
```
Pour éviter de dupliquer la traduction, ce code peut être écrit comme suit:
```yaml
example:
  label:
    en: Name
    fr: Nom
```

### Presets

Toutes les traductions des *presets* sont déjà incluses. Alors, lorsque vous modifiez l'un des *presets*, veuillez appliquer les modifications pour sa traduction également.

Lors de la création d'un nouveau *preset*, les traductions (pour les éléments en nécessitant) doivent être ajoutées sous le groupe de premier niveau des *presets*.

- En général, durant l'appel du fichier, la valeur "presets"  est assignée au paramètre *id* des *presets*: `{% include file.yml id=idPreset %}`.
- Vous pouvez utiliser la variable `id` au lieu de `idPreset` quand vous désirez utiliser l'id défini dans la page *config*. Ainsi, pour éviter tout type d'erreur, les traductions doivent être ajoutées sous l'élément du premier niveau correspondant portant le nom de `id` au lieu de la chaîne de caractères "*preset*".

### Widgets

Voici la bonne façon pour traduire un *widget*:

- Pour chaque *widget*, ajoutez un élément au deuxième niveau (sachant que le premier niveau peut correspondre à *preset*, *admin*, *oss*, etc.). Le nom de ce paramètre doit être identique à la valeur du paramètre `title` présente dans le fichier *config*.Par exemple:
```yaml
first-level:  # either preset, admin, code, oss, standard, etc...
  example:  # replace example with the title value of the widget
  [...]
```
- Vous aurez également besoin d'ajouter un paramètre au troisième niveau sous le nom de `title`. Ce paramètre renferme la version française et anglaise de la valeur qui le définit. Cette valeur (du paramètre `title`) apparaît en tant que titre d'une section dans la page de formulaire ainsi qu'en description dans la page de schéma. Voici un exemple permettant d'illustrer cette explication:
```yaml
first-level:
  example:
    title:
      en: Example
      fr: Exemple
```
L'exemple ci-dessus représente le modèle de base associé à chaque *widget*. Cependant, chaque *widget* a ses éléments spécifiques à ajouter. Ces éléments sont présentés dans les quatre sections qui vont suivre.
#### String
Voici le modèle à appliquer à ce *widget*:
```yaml
first-level:
  example:
    title:
      en: Example
      fr: Exemple
    label:
      en: The english label
      fr: The french label
```

#### String-i18n
Voici le modèle à appliquer à ce *widget*:
```yaml
first-level:
  example:
    title:
      en: Example
      fr: Exemple
    labels:
      en:
        en: The english label for the english page
        fr: The french label for the english page
      fr:
        en: The english label for the french page
        fr: The french label for the french page
    schema:
      en: The generic english label for the schema (without specificity for either english of french)
      fr: The generic french label for the schema (without specificity for either english of french)
```
#### Select

Voici le modèle à appliquer à ce *widget*:
```yaml
first-level:
  example:
    title:
      en: Example
      fr: Exemple
    options:
      option-name:  # where option-name is the value added in the options array in the config file
        en: Option
        fr: Option
     [...]
```
#### Group

Voici le modèle à appliquer à ce *widget*:
```yaml
first-level:
  title:
    en: Example
    fr: Exemple
  labels:
    string:  # replace string with the title of a string widget
      en: The english value for the label
      fr: The french value for the label
    string-i18n:  # replace string-i18n with the title of a string-i18n widget
      en:
        en: The english value for the english page
        fr: Then french value for the english page
      fr:
        en: The english value for the french page
        fr: The french value for the french page
  titles:
    widget-name:  # replace widget-name with each widget names
                  # The title is used for the schema page
      en: Widget Name
      fr: Nom du widget
   [...]
```
## Javascript
Chaque formulaire nécessite son propre JavaScript personnalisé.

Tous les scripts se situent dans le dossier `assets/js/src/`. Les scripts de chaque formulaire suivent la convention *camelCase* (soit `[form id]Form.js`). Certains scripts sont inclus dans la catégorie des utilitaires:
- `programmingLanguages.js` pour ajouter/retirer un/des langage(s) de programmation du *preset* correspondant
- `tags.js` pour ajouter/retirer un/des tag(s) du *preset* correspondant

### Liens de bas de page
Les liens vers les scripts sont ajoutés dans le bas de page du fichier HTML suivant: `_includes/footer.html`.

Au bas du fichier, un morceau de script est présent permettant de déclarer certaines constantes utilisées dans d'autres fichiers de script: `REPO_NAME`, `USERNAME` et `PRBOT_URL`. Leurs valeurs de ces paramètres sont récupérées du fichier *yml* `_config.yml` et "*pulled*" via Jekyll/Liquid. Les scripts pour les formulaires sont ajoutés juste en haut du morceau de script mentionné précédemment. Par la suite, le script est ajouté dans sa page de formulaire correspondante avec un simple `if` en utilisant le paramètre `ref` (déclaré dans l'en-tête de la page).

### PRB0T
[PRB0T](https://github.com/PRB0t/PRB0t) est une solution OS qui a été "*[forked](https://github.com/j-rewerts/PRB0t)*" et personnalisée afin de satisfaire nos besoins. En bref, nous avons fusionné les fichiers nécessaires avec le nouveau contenu "*pulled*" du formulaire puis nous avons soumis une "*pull request*".

### Fichiers JavaScript

Au début des fichiers *js*, il existe un bloc de commentaires expliquant au **ESLint** que certaines fonctions sont existantes, mais dans un autre fichier. Aucune erreur n'est alors affichée.

On retrouve ensuite sous le bloc de commentaires deux objets javascript déclarés constants. Sachant qu'ils sont utilisés tout au long du fichier, les déclarer au tout début est plus efficace notamment en terme de performance.

Il existe aussi le *jQuery*, l'équivalent de `document.ready`, dans lequel nous avons ajouté la liaison de fonction entre différentes sélections pour le remplissage automatique (des champs par exemple), le *submit* (l'envoi du formulaire complété) et la réinitialisation du formulaire.

#### *Submit*

Avant que le formulaire puisse être soumis, celui-ci passe par une phase de validation. Des alertes sont lancées jusqu'à ce que le formulaire soit complètement valide. Cette validation s'effectue avec la fonction `submitInit ()` de `validation.js`.


#### *Reset*

Certains formulaires nécessitent une fonction spécifique pour la réinitialisation. Particulièrement lorsqu'il s'agit de mots-clés et de langages de programmation. Par exemple, les utilisateurs sont en mesure d'ajouter et de supprimer des mots-clés et nous voulons nous assurer de pourvoir les réinitialiser, car par défaut, ces champs ne sont pas réinitialisés.

#### getObject

La fonction `get [form id] Object ()` prend toutes les valeurs des entrées du formulaire en cours puis les attribue à une variable de type objet (*object*). Cet objet suit la hiérarchie comme le schéma pour le formulaire. Il est séparé en deux sections. Tout d'abord, tous les champs obligatoires sont ajoutés à l'objet. Ensuite, la fonction examine chaque champ non obligatoire, vérifiant s'il a une valeur ou non. S'il a une valeur, le champ non obligatoire est ajouté à l'objet. De cette façon, aucune clé avec des valeurs vides ne sera ajoutée aux fichiers de données.

#### addValuesToFields / resetFields

Lorsque l'utilisateur sélectionne une administration ou un projet déjà existant, les données associées à la sélection sont extraites de GitHub. Par la suite*addValuesToFields* remplit certains champs avec les données extraites de GitHub. Si l'utilisateur choisit de rétablir les valeurs par défaut (soit *null*), le *resetField* supprime les valeurs ajoutées automatiquement aux champs provenant des données extraites précédemment. Dans les deux cas (*addValuesToFields* ou *resetField*), ce ne sont pas **tous** les champs du formulaire en cours qui sont automatiquement remplis. Par exemple, dans le formulaire pour les logiciels ouverts, la sélection d'une administration et d'un logiciel existant ne remplissent pas automatiquement les mêmes champs et la réinitialisation d'une sélection ne signifie pas que l'autre sélection est également réinitialisée .
